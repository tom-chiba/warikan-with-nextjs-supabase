# 0005. 購入品追加後のフォームリセット時に購入日を保持する

日付: 2025-10-18

## ステータス

Accepted

## コンテキスト

購入品追加後、フォームをリセットする際に全てのフィールドがデフォルト値に戻されていた。これにより以下の問題が発生していた：

1. **同日リストの更新バグ**: フォームリセット時に購入日が今日の日付に戻るため、過去の日付で追加した場合に同日リストのキャッシュ無効化が正しく動作しない
2. **ユーザー体験の低下**: 連続して同じ日付の購入品を追加する際、毎回日付を選び直す必要がある

具体例：
- ユーザーが2025-10-15を選択して購入品を追加
- フォームリセット後、日付が2025-10-18（今日）に戻る
- 2025-10-15の同日リストが更新されない
- 次の購入品も2025-10-15に追加したい場合、再度日付選択が必要

実装箇所: `app/(authenticated)/_hooks/usePurchaseForm.ts:83-91`

## 決定

購入品追加後のフォームリセット時に、**購入日のみを保持**する設計を採用した。

```typescript
onSuccess: async (_data, variables) => {
  await onSuccessCreatePurchase?.(variables.date);
  // 日付を保持したままフォームをリセット
  form.reset({
    ...getPurchaseFormDefaultValues(purchaserNames.data ?? []),
    date: variables.date,
  });
  toast.success("購入品を追加しました");
}
```

さらに、`onSuccessCreatePurchase`コールバックに購入日を渡すように型定義を変更：

```typescript
onSuccessCreatePurchase?: (purchaseDate?: Date) => Promise<void> | void
```

これにより、コールバック内で正確な購入日を使用してキャッシュを無効化できるようになった。

## 理由

### 1. バグ修正

**根本原因**: コールバック実行時点でフォームがリセットされ、日付情報が失われていた。

**修正前の問題**:
```typescript
// ClientForm.tsx（修正前）
() => {
  queryClient.invalidateQueries({
    queryKey: ["purchases", "same-date", format(new Date(), "yyyy-MM-dd")],
    //                                          ^^^^^^^^^^^^^ 常に今日の日付
  });
}
```

**修正後**:
```typescript
// ClientForm.tsx（修正後）
async (purchaseDate) => {
  const formattedDate = purchaseDate
    ? format(purchaseDate, "yyyy-MM-dd")
    : undefined;

  if (formattedDate) {
    await queryClient.invalidateQueries({
      queryKey: ["purchases", "same-date", formattedDate],
      //                                    ^^^^^^^^^^^^^ 実際の購入日
    });
  }
}
```

### 2. UX改善

連続して同じ日付の購入品を追加する際の操作回数を削減：
- **修正前**: 日付選択 → 入力 → 追加 → **日付選択** → 入力 → 追加...
- **修正後**: 日付選択 → 入力 → 追加 → 入力 → 追加...（日付選択不要）

### 3. 一貫性

他のフィールドはリセットされるが、日付は保持されることで：
- 同じ日付の複数の購入品を効率的に入力できる
- 日付を変更したい場合は明示的に選択し直す（意図的な操作）

## 結果

### 良い影響

1. **バグ修正**: 過去の日付での購入品追加時に同日リストが正しく更新される
2. **UX向上**: 連続入力時の手間が削減される
3. **型安全性**: コールバックの型定義により、購入日の受け渡しが明確
4. **テスト可能性**: 購入日を引数で受け取るため、テストが容易

### 悪い影響・トレードオフ

1. **標準動作との乖離**: 一般的なフォームは全フィールドをリセットするが、日付のみ保持する特殊な動作
2. **意図しない日付での追加リスク**: ユーザーが日付が保持されていることに気づかず、誤った日付で追加する可能性（ただし、日付は常に表示されているため軽微）
3. **実装の複雑性**: シンプルな`form.reset()`ではなく、デフォルト値をマージする必要がある

### トレードオフの判断

UXの向上とバグ修正のメリットが、標準動作との乖離によるデメリットを上回ると判断した。理由：
- 購入日は画面上に常に表示されており、ユーザーが確認可能
- 連続入力は頻繁に発生するユースケース
- 日付を変更したい場合は1クリックで変更可能

## 代替案

### 1. フォームを完全リセット（修正前の動作）

```typescript
form.reset(); // 全フィールドをデフォルト値に戻す
```

**メリット**: 標準的な動作、実装がシンプル
**デメリット**: バグが発生、UXが悪い

**不採用理由**: バグ修正が最優先

### 2. 日付をグローバルステートで管理

```typescript
// Zustandなどで日付を管理
const [selectedDate, setSelectedDate] = useStore();
```

**メリット**: フォームリセットの影響を受けない
**デメリット**: 状態管理が複雑化、既存のフォーム管理と整合性が取れない

**不採用理由**: React Hook Formの設計と乖離、過剰な設計

### 3. モーダル内でフォームを表示

```typescript
// モーダルを閉じる＝フォームリセット
<Dialog onClose={() => form.reset()}>...</Dialog>
```

**メリット**: 追加のたびにフォームがクリアされる
**デメリット**: 連続入力がしにくい、UI変更が大きい

**不採用理由**: 既存のUI設計を大きく変更する必要がある

### 4. 「同じ日付で続けて入力」チェックボックス

```typescript
const [keepDate, setKeepDate] = useState(false);

form.reset({
  ...defaultValues,
  date: keepDate ? variables.date : new Date(),
});
```

**メリット**: ユーザーが動作を制御できる
**デメリット**: UIが複雑化、デフォルトでバグが残る

**不採用理由**: 設定項目が増えるとUXが低下、ほとんどのユースケースで日付保持が望ましい

## 関連する決定

なし

## 参考

- 修正前のバグ: `ClientForm.tsx:61` - 固定の`new Date()`でキャッシュ無効化
- 修正後の実装: `usePurchaseForm.ts:83-91` - 購入日を保持したフォームリセット
- テストケース: `ClientForm.comp.test.tsx:460-601` - 過去の日付での購入品追加テスト
